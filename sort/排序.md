# 内部排序的分类

- 插入排序：直接插入排序、折半插入排序、希尔排序
- 快速排序
- 选择排序：简单选择、树形选择排序、堆排序
- 归并排序

# 1.插入排序

## 1.1直接插入排序

思路：
- 已知前面数值区间为递增数组，逐一将后面的数值注入到排序数组中
- 设定一个哨兵`nums[0]` 就是一个临时内存。

首先将第一个数值认定为排序数组，从第二数值开始迭代插入，未找到插入位置
时，将数值后移，再插入第一个大于的数值的位置之后。

```$xslt
    // 简单插入排序
    public  static void simpleInsertSort(int[] nums){

        for(int i=2; i<nums.length; i++){
            if(nums[i]<nums[i-1]){
                nums[0] = nums[i];
                nums[i] = nums[i-1];

                int j=i-2;
                while(nums[j]>nums[0]) {
                    nums[j + 1] = nums[j];
                    j--;
                }
                nums[j+1] = nums[0];
            }
        }
    }
```

## 1.2折半插入排序

思路：和简单插入排序一样，改进的地方在于，使用二分查找来搜索待插入节点位置。\
折半查找减少了判断语句的次数，但是移动节点数目没有改变，时间复杂度和`简单插入排序`一样。

代码见InsertSort.java。

## 1.3 shell排序

思路：对于基本有序的数组，使用直接插入排序，具有较高的效率。针对这个思路\
将一次排序分为多个不同增量的子序列的直接插入排序。

# 2.交换排序

## 2.1冒泡排序

思路：对于从小到大排序，使用一个循环将最大值交换至最底位置，然后然后收缩交换区间，直到在一趟交换
中没有发生交换。

## 2.2快速排序

思路：划分+递归\
使用双指针法，以区间数组首元素为枢轴值，将数组划分成左、右两个区间。满足条件：左区间全小于
枢轴值，右区间全大于等于枢轴值。一次划分能够确定枢轴值在整个区间中的位置。

递归，通过自顶向下地调用划分函数，递归地划分左右区间，并确定其枢轴值的位置。最终实现快速排序。

# 3.选择排序

## 3.1堆选择

思路：
1. 定义一个整堆函数，其功能是：将仅将根节点修改的堆（此时根节点不满足堆定义），整理成堆
2. 使用整堆函数，对非根节点自底向上，自右向左地整堆，构建一个初始堆
3. 利用大顶堆的结构，不断地交换堆顶与最后一个数值、整堆


# 4.归并排序

 思路：采用分治+递归的方法
 1. 将一个数组分成若干个有序子序列，如果两个子序列两两合并成有序序列
 2. 使用递归地方式，实现整个序列两两归并
 
 
# 几种排序算法时间复杂度的分析

|排序方法|平均时间|最坏情况|内存|
|:---:  |:---:|:---:|:---:|
|冒泡排序|n^2  |     | 1   |
|快速排序|nlogn|     | logn|
|简单插入排序|n^2 |   |  1  |
|希尔排序|n^1.5|      | 1  | 
|堆排序  |nlogn|     |  1  |
|归并排序|nlogn|     |   n |
